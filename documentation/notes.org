* Notes

This is a framework to analysis mdsplus data on the fuze experiment. It also includes some analysis code for a digital holographic inteferometer.


* DHI Analysis

** Reconstruction

To perform the reconstruction, first, a fresnel transformation is taken of each of the two images (images with and without a plasma).


---- Fresnel Transformation ----

The fresnel transformation starts by applying hyperbolic filter to the image. This filter will first apply a smoothing function across each row, then apply the same smoothing function down each column. There is a smoothing parameter for this, called the hyperbolicWin (defaults to 8).

Then, you multiply the image by the complex "chirp" function, and the reference beam (which is just 1.0).

Then, you perform a 2D FFT (done by a series of 1D FFT's in the C code using the GSL). The result is then has the upper left and lower right quadrants exchanged, and then the upper right and lower left quadrants exchanged. The result is the a complex matrix that represents the complex wave amplitude of the holographic reconstruction.

----------------------------------


At this point, you simply find the phase difference between the complex wave amplitudes of the holographic reconstructions with and without plasma. Then, you extract the section that corresponds to the 1st order, object wave (virtual or conjugate/diverging). The phase difference in this extracted image now represents the phase shift of the laser beam caused by the presence of the plasma.

Then, a reducing procedure is performed, where every "sampleInterval"th element is sampled and placed into a new matrix that is smaller in size.


---- Smoothing and Unwrapping Procedure -----

After that, this new, smaller, reduced size matrix representing the phase, is smoothed over and unwrapped together. This first step involves taking the sine and cosine of the phase angle. 

Then, a simple box car smoothing procedure is applied to the sine and cosine of the phase angle. This box car smooth width is set by the "boxCarSmoothWidth" parameter. The returned matrix after the box car smoothing will be smaller, because the edges that don't contain enough points for an average and will be discarded. 

Then, the smoothed sine and cosine matrices will be used to re-generate the phase, in a new, slightly smaller phase matrix. 

Finally, that new phase matrix is "unwrapped". The unwrapping procedure goes through first each column, then each row. The procedure will look for phase jumps then a threshold, set by "unwrapThresh" (defaults to 1.0 x pi), and add or subtract 2pi, depending on the sign of the jump. This will account for phase transitions that go outside of the -pi -> +pi domain of the atan function. 

At this point, the unwrapped and smoothed phase matrix has the maximum value subtracted from it at all points. This creates a zero baseline that all phases are referenced to. Later, a +1/-1 will be mulitplied by the phase when converting to density.

-----------------------------------------------


Finally, the phase is converted to plasma density by a simple formula. This matrix is now the line integrated plasma density.





** Abel Inversion

Now, the line integrated plasma density must be converted to plasma number density. This procedure is more complicated.

It will iterate through each column, which is meant to be in an orientation where the column runs in the y-direction, or perpendicular to the z-direction, the direction of the pinch. For each column, it will do the following:


------- Each Column Iteration ---------

It will pick the center to be the maximum value in the column. It will use this center value to divide the column up into a "Left" and "Right" line integrated profile. The "Left" profile is 0 -> the center value.

Then, it will iterate this center value from -"centroidNum" to +"centroidNum" around the maximum value (set to 10). For each center value, it will do the following:


------- Each Value for the "Center" ---------

It will start by dividing up the column into a "Left" and "Right" line integrated profile.

Then, it will subtract the minimum value from both the "Left" and "Right" line integrated profile.

Then, it will invert each "Left" and "Right" line integrated profile, to obtain a "Left" and "Right" density profile.

At this point, it will try to determine an approriate density offset for the smaller of the two profiles. To do this, it will iterate through a number of different density offsets determined by the parameters "deltaN" (set to 5E21) and "offsetIter" (set to 15). It will apply these offsets to the smaller radial density profile, and determine the sum of the square of the differences between the smaller profile, and the truncated larger profile. It will then find the density offset that minimizes this sum. This will be the density offset that it applies to the smaller of the two profiles.

Now that the density offset has been determined, the code will find the sum of the squares of the difference between the smaller density profile, and truncated larger density profile. The code will find the centroid value, or center pixel value to divide the column into a left and right line integrated density profile, that minimizes this sum. This will then be the center pixel value, or centroid value, that is used for that column.

-------------------------------------


That center value that minimizes the L2 norm between the smaller and large radial density profiles (the sum of the squares of the differences between the small and truncated large radial density profile) is what will be recorded as the actual inverted radial density profile. Remember that the appropriate density offset was also found for the smaller of the two profiles. So the "Left" and "Right" radial density profiles will be glued together, yielding the 2D inverted plasma radial density profiles.

Finally, the code will apply an axial phase correction. I'm not sure this code is necessary, but here is what it does:


------ Axial Phase Correction -----------

It will start by iterating through each column. 

Then, it will longer of the two profiles, and calculate the length = dy x The length of the longer profile. From this length, it will calculate a distance, 2 x sqrt(Relec^2-length^2), which is path length of the edge chord of the longer profile.

Then, it will divide the top or bottom value of the line integrated profile that column, by this distance. This value will then be an offset that is ???added??? to the ???longer???? profile.




** Junk 

So the holographic analysis goes like this:

You start by reading in the JPG file. This is a compressed file. It has to be decompressed. The JPG file will be 3 color values for each pixel (RGB). You convert this to a single value based on:
red = 0.3
green = 0.59
blu = 0.11
Meaning you add all 3 values together, weighted by the above values. You should do this for a shot with plasma (plasmaShot) and a shot with no plasma (vacuumShot).

Then, apply multiple the length and width of each shot by a hyperbolic function. The matlab code for this is:
L = size(hol_def);
M = L(2);  % x-direction
N = L(1);  % y-direction

param = 8;
x2 = linspace(-param*pi,param*pi,M+1); x = x2(1:M);
y2 = linspace(-param*pi,param*pi,N+1); y = y2(1:N);

for i = 1: length(hol_def(:,1))
    hol_def(i,:) = hol_def(i,:).*(tanh(x+(param-1)*pi)-tanh(x-(param-1)*pi));
    hol_base(i,:) = hol_base(i,:).*(tanh(x+(param-1)*pi)-tanh(x-(param-1)*pi));
end

for j = 1: length(hol_base(1,:))
    hol_def(:,j) = hol_def(:,j).*(tanh(y+(param-1)*pi)-tanh(y-(param-1)*pi))';
    hol_base(:,j) = hol_base(:,j).*(tanh(y+(param-1)*pi)-tanh(y-(param-1)*pi))';
end

Notice the parameter is 8. I'm not sure if that should ever be varied. This hyperbolic window should stop the "Gibbs Phenomena".

Then, you use the Fresnel method to reconstruct the complex amplitude of each scene beam (the plasma and vacuum). This is basically an approximation of the physical process of a hologram. You basically digitally have each small wavelet being transmitted off of the image. So each wavelet is attenuated by the transmittance of the image. You can approximate the double integral involved in this by an FFT of the image multiplied by an exponential. The matlab code for this process is:

% Constants:
res = (3.85e-6); % [m] Pixel size of Nikon 3200D 4.3e-6 for Canon Rebel T2i

% Declaring pixel and sensor size in the hologram plane:
L = size(hol);
M = L(2);      % number of pixels along x-direction
N = L(1);      % number of pixels in y-direction
del_xi = res;  % pixel size in x-direction
del_eta = res; % pixel size in y-direction
chirp = ones(N,M);

% Computing the length scales in the reconstruction plane:
xsize_fres = abs(d*lambda/M/res);
ysize_fres = abs(d*lambda/N/res);
xfres = [-(M/2)*xsize_fres:xsize_fres:(M/2)*xsize_fres];
xfres = xfres(1:M);
yfres = ([-(N/2)*ysize_fres:ysize_fres:(N/2)*ysize_fres]);
yfres = yfres(1:N);

k = 2*pi/lambda;

% Generating the chirp function required by the Fresnel transform:
status = sprintf('Generating chirp...')
for n = 0:N-1
        for m = 0:M-1
            
            % Chirp function:
            chirp(n+1,m+1) = exp((1i*pi/(d*lambda))*(((n-N/2)^2*...
                del_eta^2)+((m-M/2)^2*del_xi^2)));

            % Complex, constant phase factor:
            % This factor is only required if we want a correctly scaled
            % reconstructed intensity distribution.  It is not needed in
            % computing the interference phase distribution.
            % A(n+1,m+1) = (exp(1i*k*d)/(1i*lambda*d))*...
            % exp((1i*pi/(d*lambda))*(xfres(m+1)^2+yfres(n+1)^2));
            
        end
end

% Set the complex factor to 1 when only reconstructing phase.
A = 1; 

% Multiply the hologram intensity distribution with the reference beam:
hol_ref = hol*ref;

% Convolving the product of the hologram function and reference wave with 
% the chirp function.
b_base =fft2(hol_base.*chirp);
b_base =fftshift(b_base);

You do it for each one of the images to get the complex amplitude of each scene beam. The beam with plasma, and the beam without plasma.

Then, you subtract the two phases of each scene beam, and get one real value for the phase difference between the scene beam with, and the scene beam without plasma.

At this point, the image is sampled every 10 points across in the columns, and down the rows. So information is thrown away. Then, there is a smoothing procedure. The smoothing procedure starts by taking the sine and cosine of the image (now with 9 out of 10 points removed). Then, it does a box car average over both the sine and cosine values. This keeps the image size the same, but just replaces each point with an average over a box around that point. For the edge points where a box doesn't fit, it just sets the value equal to the nearest value where a box does fit. Then, the arctangent of the sine / cosine image is taken. This gets us the phase back. Then, we do an unwrapping procedure which is basically the matlab unwrap function. It is looking for situations where the phase may have exceeded +/- pi, and rolled over. It goes first across the columns, then down the rows and checks for instances where the phase changes by more the pi (the threshold, somewhat arbitrary). In these situations, and adds +/- 2pi to every subsequent element. This unwraps the image in the sense that it allows for phase variations greater then 2 pi. Then, finally, the maximum phase is subtracted from the from the unwrapped phase. I'm not sure what that does exactly?

At this point, it converts the phase to plasma density by the formula:
den_int_full = sign_twin*[unwrapped/((-q^2/(4*pi*c^2*me*e_0))*lambda)];
where,
% Declare constants and ZaP-HD plasma parameters:
e_0 = 8.85e-12; % Permitivity of free space
mu_0 = 1.257e-6; % Permeability of free space
k = 1.38e-23; % Boltzmann's constant in SI units
q = 1.6e-19; % electron charge [C]
c = 3e8; % speed of light [m/s]
mi = 1.67e-27; % proton mass [kg]
me = 9.12e-31; % electron mass [kg]
lambda = 532e-9; % laser wavelength [m]
R_electrode = 8*2.54/100;


Then, the mininum density is subtracted from the density. That seems to make sense because the laser likely passes through zero plasma density at some point.

The physical x and y values are now defined by:
delta X = abs(d*lambda/M/res)
delta Y = abs(d*lambda/N/res)
where, M = the number of columns, N = the number of rows, d = the reconstruction distance, and res = the pixel size of the camera.

And now you have the line-integrated density.

Our unwrapping procedure looks for phase jumps for some threshold value of pi. We have been using 1.0. The phase jump should be by 2pi, though. The phase is confined between +/- pi.

Before, we were first taking every 10th point from the image, after the fresnel transformation. Then, we were applying a box car smooth (8). This made the computational time speed up. 

Now, we are taking all the points, and doing a box car smooth of 100. That improved things a little. 

The density offset procedure I do is:

For each centroid iteration, it will iterate through a number of density offsets, both positive and negative, apply them to the smaller cross section, and determine which one best minimizes the L2 norm of the different between the small profile, and truncated larger profile. I think this is what M. Ross's code it doing. I have this commented out.

The issue with the abel inversion, is when it doesn't go to zero, you get a large point on the outer shell. Then, this outer shell is a false data, and the geometry is included incorrectly in the rest of the inversion routine. I think we want to set this to zero, then add an offset to match... where?

We unwrap each row first, then each column. 

Should we box car average the phase, then take the sin/cos, or do we have been doing which is take the sin/cos, then do a box car average?

About the abel inversion. I think that we want to force one end to zero, then have the the

After you get the phase map, the maximum value is subtracted.

Previously, mike ross would calculate the sine and cosine of the phase, then do a box car smoothing. Then, he would re-calculate the phase using atan. Then, he would unwrap the phase.

Now, I'm just unwrapping the phase, then doing a box car average.

Now, I'm seeing really confusing results. The new procedure which just unwraps the phase, then does a box car smooth over the unwrapped phase, is producing results that don't make a ton of sense. They are radically different from what was obtained using the previous method. I'm trying to track the phase in the reconstructed twin image, and it's hard to make sense out of it. 


So the abel inversion goes like this.

You start by getting the "Number of Cross Sections" or basically the column number. Then, you iterate through each column. 

Here is what you do for each column. Find the maximum value, and it's index. 

You set a number of centroids to 10. That means, I think, you have 10 cocentric circles at each different radii.

Then you take the index of the maximum value, and subtract the number of centroids.

Then, check and see if your index is outside of the range of the image. If it is, then you set the left and right density for that column to NaN for all rows. It also sets the cenroid valve for that column to 0. I think that is suposed to be the center? Then, you are done.

If that index value is inside the matrix range, check to see if it is close to the upper boundary (less then 2 times the number of centroids). If it is, then it decreases the number of centroid iterations by the difference between the index, and 2 times the number of centroids.

Otherwise, its sets the number of centroid iterations to 2 times the number of centroids.

Now, it starts to iterate through the centroid iterations. At each centroid iteration it:

It gets a left and right profile, from the maximum value index to the begining of the column, and the maximum value index to the end of the column.

Then, it applies an abel inversion to theleft and right vectors minus the minimum value of the vector. This abel inversion is starting with a square matrix that each side is the length of the vector. Every elements starts at zero. Then, its sets the element like this:

for k = length(den_int):-1:1
    for i = k:-1:1
       
        A(k,i) = sqrt(((k+1))^2-(i)^2)-sqrt((k)^2-(i)^2);
        
    end
end

A = 2*dr*(A');

Then, does a matrix left divison to solve for the radial density:
den_num = A\den_int;

The matrix appears to be a marix with the half of the matrix zero, and the other half non-zero (split at the diagonal), like a triangle. The top row is full, the bottom row has one value. Each value appears to be

A(i, j) = sqrt((j+2)^2 - (i+1)^2) - sqrt((j+1)^2-(i+1)^2)
Matrix values are only for i <= j, or top left diagonal.

A is a square matrix,
A(length of half cross section, length of half cross section)

So if,
M = (3,3)
A = (3,1)
B = (3,1)

B = M x A

Then,

A = M\B


So,
A(i, j) is the contribution from the jth circle (0 being the inner most circle), that adds to the ith cross section element/chord (just half, 0 being the chord through the center)

A(i, j) = sqrt((j+2)^2-(i+1)^2) - sqrt((j+1)^2-(i+1)^2)

So j = 0 is the inner most circle contribution,
and i = 0 is the 0th chord that runs through the center

sqrt((j+1)^2-(i+1)^2)

the jth circle has a radius of (j+1). 

The ith chord has an impact parameter of (i+1).

That means that it will the ith chord will intersect the jth circle at an x value of,
sqrt( (j+1)^2-(i+1)^2)
and that the ith chord will intersect the j-1 circle at an x value of,
sqrt( (j+1)^2-(i+1)^2)

So then basically you just subtract the two x values to get the x distance that the chord will pass through the (j+1)th circle
sqrt( (j+2)^2-(i+1)^2) -    sqrt( (j+1)^2-(i+1)^2)    = A(i,j) 
Mikes Formula:
sqrt( ((j+2))^2-(i+1)^2) -  sqrt((j+1)^2-(i+1)^2)     = A(i,j) 


So I think this should work:

A(i, j) = 2 x dr x sqrt( (j+2)^2 - (i+1)^2)   -   sqrt( (j+1)^2 - (i+1)^2)
where i<=j

This basically just gets the distance that a line at impact parameter i, will travel with circle j, where i = 0 corresponds to a chord through the center (exactly through the center??), and j = 0 corresponds to the inner most circle.

This needs to be tested.

Then, make sure both the left and right sides lengths match. So the longer of the two must be truncated.

Okay, let's start over:
The line integrated density is starting at the maximum i =0. That is the chord that passes through the center.

That doesn't actually work.

Mike's Code (Verified this):
A(i,j) = sqrt((j+1)^2-i^2)-sqrt(j^2-i^2);
for i <= j

Converted to C (Verified this):
A(i,j) = sqrt((j+2)^2-(i+1)^2)-sqrt((j+1)^2-(i+1)^2);
for i <= j


Here is my issue. So for j = 1, the inner most circle, and i =1, the inner impact parater,

sqrt (2^2 - 1^2) - sqrt( 1^2 - 1^2)

sqrt(3) for the length???

For j = 2, the second inner most circle, and i = 1, the smallest impact paramter,
sqrt(3^2 - 1^2)  - sqrt( 2^2-1^2)

sqrt(8) - sqrt(3)
That would make sense if the path length through the 2nd inner most circle was sqrt(8), but the max it could be is 2, and sqrt(8) is 2.82.


For my formula (except for j = 0, i = 0),

sqrt( (j+1)^2 - 0.25*(i+1)^2) - sqrt( j^2  - 0.25*(i+1)^2)

For j = 0, the inner most circle, and i = 0, the inner impact parameter,

sqrt( 1^2 - 0.25*1^2)

sqrt(0.75)

Kind of makes sense, less then 1,


And then for j = 1, the second inner most circle, and i =0, the smallest impact parameter,

sqrt( 2^2 - 0.25*1^2)  - sqrt(1^2 - 0.25*1^2)
sqrt(3.75) - sqrt(0.75)

I guess if sqrt(3.75) = 1.93, that is less then 2, so that kind of makes sense.

But what about the case where you i = j?

i = Impact parameter
j = Shell parameter


for i = 0, that is the line through the middle. 




After the abel inversion, Mike goes in makes sure that both the left and right sides are the same size.

Then, he goes int and checks to see a value for 0 density at the edge as the density in the longer profileat the radius of the shorter profile.



I think he goes the abel inversion based on a number of different centroid locations, and looks for the one that is most symetrical. Then, he uses that one, I think.


So here is my formula:

  /* 
   * Here is the method I came up with to get the length of the
   * chord of impact parameter ii, through the shell, jj. The chord
   * is the chord through the center of the 1 pixel width rectangle
   * that passes through the plasma
   */
  for (jj = 0; jj < 10; jj++) {
    for (ii = 0; ii <= jj; ii++) {

	num = sqrt(gsl_pow_2(jj+1)-
		   gsl_pow_2(ii+0.5))
	  -sqrt(gsl_pow_2(jj)-
		gsl_pow_2(ii+0.5));

	gsl_matrix_set(myMethod, ii, jj, num);
	
    }
  }

  /* 
   * Double back over cases where i = j, because the formula doesn't work
   * for that case.
   */
  for (jj = 0; jj < 10; jj++) {

	num = sqrt(gsl_pow_2(jj+1)-
		   gsl_pow_2(jj+0.5));

	gsl_matrix_set(myMethod, jj, jj, num);
	
  }


Here is Mike's formula:

  /* 
   * This method (m-file) but 0-9 instead of 1-10:
   * for j = 1:1:10
   *   for i = 1:1:j
   *      A(i,j) = sqrt(((j+1))^2-(i)^2)-sqrt((j)^2-(i)^2);
   *   end
   * end
   * This is what Mike does in this code. I don't know what ii, and
   * jj correspond to, I think ii = impact parameter, j = shell
   */
  for (jj = 0; jj < 10; jj++) {
    for (ii = 0; ii <= jj; ii++) {

      num = sqrt(gsl_pow_2(jj+2)-
		 gsl_pow_2(ii+1))
	-sqrt(gsl_pow_2(jj+1)-
	      gsl_pow_2(ii+1));
      
      gsl_matrix_set(mikeMethod, ii, jj, num);

    }
  }


So you are in a big for loop for each column/cross section, that is iterating through "centroids_iterations", which is set to 2 times the number of centroids, or "num_of_centroids". In this case, it's 20.

You are keeping track of a of each profile, and each "centroid_ind_temp", which is set to initially the maximum index - the number of centroids. In this case, it's the maximum index subtracted by 10. You are also keeping track of the edge values.

Okay, so once the matrix has been inverted, you have a left and right radial density profile. This is starting a r = 0, and going out by the "num_of_centroids", I think.

Then,  you make sure that both the lengths of the left and right profiles are equal. If not, set them equal.

Then, you want to find an edge value. That is the longer profile's density at the radius of the short profile.


Then, for some reason that I don't understand, they do a for loop through a number of edge values, or essentially background values. But appears they only subtract it off of one of the profiles, the left or the right. Then, he subtracts the 2 matrices from another. Then, he calulates the matlab "norm" of that matrix , which is just the max(svd(M)), and normalizes that to the vector length. At that point he appears to find the minimum value, and set that equal





